"""
GraphQL Federation Subgraph 2 Worker
This worker provides GraphQL federation capabilities as a subgraph, 
based on the RestAPI Worker structure but using GraphQL federation schema.
"""
from multiprocessing.connection import Connection
import traceback
import threading
import uuid
import asyncio
import time
from typing import Dict, Any, List, Optional
import json

from utils.log import log 
from utils.handleMessage import sendMessage, convertMessage
from .Worker import Worker
from json_response_types import (
    json_response_types, 
    BaseResponse, 
    WorkerResponse, 
    ChatEntity, 
    PromptEntity, 
    ProgressEntity,
    ResponseStatus,
    create_success_response,
    create_error_response,
    create_processing_response,
    FEDERATED_ENTITY_MAPPINGS
)

# Simulated GraphQL federation schema (would use strawberry-graphql in production)
class GraphQLFederationSubgraph2Worker(Worker):
    """
    GraphQL Federation Subgraph 2 Worker
    Provides GraphQL federation endpoints that mirror RestAPI functionality
    """
    
    def __init__(self):
        self.conn: Optional[Connection] = None
        self._port: int = None
        self.requests: Dict[str, Dict] = {}
        self.schema_registry = {}
        self.resolvers = {}
        self._setup_federation_schema()
        
    def _setup_federation_schema(self):
        """Setup GraphQL federation schema and resolvers"""
        # Federation schema definition (would be generated by strawberry-graphql)
        self.federation_schema = {
            "Chat": {
                "fields": ["id", "chat_id", "prompt", "project_id", "status", "progress"],
                "keys": ["chat_id"],
                "resolver": "resolve_chat"
            },
            "Prompt": {
                "fields": ["id", "project_id", "content"],
                "keys": ["project_id"],
                "resolver": "resolve_prompt"
            },
            "Progress": {
                "fields": ["id", "chat_id", "progress_name", "status", "data"],
                "keys": ["chat_id", "progress_name"],
                "resolver": "resolve_progress"
            }
        }
        
        # Register resolvers
        self.resolvers = {
            "resolve_chat": self._resolve_chat,
            "resolve_prompt": self._resolve_prompt,
            "resolve_progress": self._resolve_progress,
            "query_chat_by_id": self.query_chat_by_id,
            "query_prompt_by_project": self.query_prompt_by_project,
            "mutation_create_chat": self.mutation_create_chat,
            "mutation_create_chat_crag": self.mutation_create_chat_crag,
            "mutation_create_chat_response": self.mutation_create_chat_response
        }

    def run(self, conn: Connection, port: int):
        """Run the GraphQL federation worker"""
        self.conn = conn
        self._port = port
        
        def run_listen_task():
            asyncio.run(self.listen_task())
        
        # Start listening for inter-worker messages
        threading.Thread(target=run_listen_task, daemon=True).start()
        
        # Start GraphQL federation server (simulated)
        self._start_federation_server()

    def _start_federation_server(self):
        """Start the GraphQL federation server (simulated)"""
        log(f"GraphQL Federation Subgraph 2 starting on port {self._port}", "info")
        
        # In a real implementation, this would start a GraphQL server
        # For now, we'll simulate with a simple loop
        while True:
            try:
                # Simulate GraphQL federation health check
                time.sleep(10)
                self._send_health_check()
            except KeyboardInterrupt:
                break
            except Exception as e:
                log(f"GraphQL federation server error: {e}", "error")

    def _send_health_check(self):
        """Send health check to supervisor"""
        if self.conn:
            sendMessage(
                conn=self.conn,
                messageId=f"GraphQLFederationSubgraph2Worker-{int(time.time())}",
                status="healthy",
                destination=["supervisor"],
                data={"service": "graphql-federation-subgraph-2", "port": self._port}
            )

    async def listen_task(self):
        """Listen for incoming inter-worker messages"""
        log("GraphQLFederationSubgraph2Worker is listening for messages...", "info")
        
        while True:
            try:
                if self.conn and self.conn.poll(1):
                    message = self.conn.recv()
                    await self._handle_message(convertMessage(message))
                
                await asyncio.sleep(0.01)
            except EOFError:
                break
            except Exception as e:
                log(f"GraphQL federation listener error: {e}", "error")
                break

    async def _handle_message(self, message: Dict[str, Any]):
        """Handle incoming messages from other workers"""
        destinations = message.get("destination", [])
        
        # Filter for GraphQL federation destinations
        relevant_destinations = [
            d for d in destinations 
            if d.split("/", 1)[0] == "GraphQLFederationSubgraph2Worker"
        ]
        
        if not relevant_destinations:
            return
            
        destination = relevant_destinations[0]
        dest_parts = destination.split('/')
        
        if len(dest_parts) >= 2:
            method = dest_parts[1]
            param = dest_parts[2] if len(dest_parts) > 2 else None
            
            # Route to appropriate resolver
            if hasattr(self, method):
                resolver_method = getattr(self, method)
                await resolver_method(message, param)

    def send_to_other_worker(self, destination: List[str], data: Dict[str, Any]) -> Dict[str, Any]:
        """Send message to other workers and wait for response"""
        task_id = str(uuid.uuid4())
        evt = threading.Event()
        
        self.requests[task_id] = {
            "event": evt,
            "response": None
        }
        
        log(f"GraphQL federation sending request to {destination} with task_id: {task_id}", "info")
        
        sendMessage(
            conn=self.conn,
            messageId=task_id,
            status="processing",
            destination=destination,
            data=data
        )
        
        if not evt.wait(timeout=30):
            # Timeout
            return {
                "taskId": task_id,
                "status": "timeout",
                "result": None
            }
        
        # Success
        result = self.requests.pop(task_id)["response"]
        return {
            "taskId": task_id,
            "status": "completed",
            "result": result
        }

    def on_processed(self, msg: Dict[str, Any]):
        """Handle response from other workers"""
        task_id = msg.get("messageId")
        if task_id in self.requests:
            entry = self.requests[task_id]
            entry["response"] = msg.get("data")
            entry["event"].set()

    # GraphQL Federation Resolvers
    
    @json_response_types(ChatEntity)
    async def _resolve_chat(self, message: Dict[str, Any], chat_id: str) -> ChatEntity:
        """Resolve Chat entity for federation"""
        try:
            # This would be called when another subgraph needs Chat data
            result = self.send_to_other_worker(
                destination=[f"DatabaseInteractionWorker/getProgress/{chat_id}"],
                data={"id": chat_id}
            )
            
            chat_data = result.get("result", {})
            return ChatEntity(
                id=chat_id,
                chat_id=chat_id,
                prompt=chat_data.get("prompt", ""),
                project_id=chat_data.get("projectId", ""),
                status=ResponseStatus.SUCCESS if result.get("status") == "completed" else ResponseStatus.ERROR,
                progress=chat_data
            )
        except Exception as e:
            log(f"Error resolving chat entity: {e}", "error")
            return ChatEntity(
                id=chat_id,
                chat_id=chat_id,
                prompt="",
                project_id="",
                status=ResponseStatus.ERROR
            )

    @json_response_types(PromptEntity)
    async def _resolve_prompt(self, message: Dict[str, Any], project_id: str) -> PromptEntity:
        """Resolve Prompt entity for federation"""
        try:
            result = self.send_to_other_worker(
                destination=[f"CacheWorker/getByKey/{project_id}"],
                data={"project_id": project_id}
            )
            
            if not result.get("result"):
                # Try database if not in cache
                result = self.send_to_other_worker(
                    destination=[f"DatabaseInteractionWorker/getPrompt/{project_id}"],
                    data={"key": project_id}
                )
            
            return PromptEntity(
                id=project_id,
                project_id=project_id,
                content=result.get("result", {})
            )
        except Exception as e:
            log(f"Error resolving prompt entity: {e}", "error")
            return PromptEntity(
                id=project_id,
                project_id=project_id,
                content={}
            )

    @json_response_types(ProgressEntity)
    async def _resolve_progress(self, message: Dict[str, Any], chat_id: str) -> ProgressEntity:
        """Resolve Progress entity for federation"""
        try:
            progress_name = message.get("data", {}).get("progress_name", "default")
            
            result = self.send_to_other_worker(
                destination=[f"DatabaseInteractionWorker/getProgress/{chat_id}"],
                data={"id": chat_id, "process_name": progress_name}
            )
            
            return ProgressEntity(
                id=f"{chat_id}_{progress_name}",
                chat_id=chat_id,
                progress_name=progress_name,
                status=ResponseStatus.SUCCESS if result.get("status") == "completed" else ResponseStatus.ERROR,
                data=result.get("result", {})
            )
        except Exception as e:
            log(f"Error resolving progress entity: {e}", "error")
            return ProgressEntity(
                id=f"{chat_id}_error",
                chat_id=chat_id,
                progress_name="error",
                status=ResponseStatus.ERROR
            )

    # GraphQL Query Resolvers (accessible via federation)
    
    async def query_chat_by_id(self, message: Dict[str, Any], chat_id: str):
        """GraphQL query: getChatById"""
        chat_entity = await self._resolve_chat(message, chat_id)
        
        response = {
            "data": {
                "chat": chat_entity.__dict__
            }
        }
        
        # Send response back
        sendMessage(
            conn=self.conn,
            messageId=message.get("messageId"),
            status="completed",
            destination=["supervisor"],
            data=response
        )

    async def query_prompt_by_project(self, message: Dict[str, Any], project_id: str):
        """GraphQL query: getPromptByProject"""
        prompt_entity = await self._resolve_prompt(message, project_id)
        
        response = {
            "data": {
                "prompt": prompt_entity.__dict__
            }
        }
        
        sendMessage(
            conn=self.conn,
            messageId=message.get("messageId"),
            status="completed",
            destination=["supervisor"],
            data=response
        )

    # GraphQL Mutation Resolvers
    
    async def mutation_create_chat(self, message: Dict[str, Any], param: str = None):
        """GraphQL mutation: createChat (equivalent to POST /chat)"""
        data = message.get("data", {})
        project_id = data.get("projectId")
        prompt = data.get("prompt")
        
        # Create new chat history
        result = self.send_to_other_worker(
            destination=["DatabaseInteractionWorker/createNewHistory/"],
            data={
                "question": prompt,
                "projectId": project_id
            }
        )
        
        chat_id = result.get("result", [{}])[0].get("_id", "unknown_id")
        
        # Send to logical fallacy worker
        sendMessage(
            conn=self.conn,
            messageId=chat_id,
            status="completed",
            destination=[f"LogicalFallacyPromptWorker/removeLFPrompt/"],
            data={
                "prompt": prompt,
                "id": chat_id,
                "projectId": project_id
            }
        )
        
        response = create_success_response(
            "Chat created successfully via GraphQL federation",
            {
                "chat_id": chat_id,
                "prompt": prompt,
                "projectId": project_id
            }
        )
        
        sendMessage(
            conn=self.conn,
            messageId=message.get("messageId"),
            status="completed",
            destination=["supervisor"],
            data=response.__dict__
        )

    async def mutation_create_chat_crag(self, message: Dict[str, Any], param: str = None):
        """GraphQL mutation: createChatCRAG (equivalent to POST /chat-crag)"""
        data = message.get("data", {})
        project_id = data.get("projectId")
        prompt = data.get("prompt")
        
        # Create new chat history
        result = self.send_to_other_worker(
            destination=["DatabaseInteractionWorker/createNewHistory/"],
            data={
                "question": prompt,
                "projectId": project_id
            }
        )
        
        chat_id = result.get("result", [{}])[0].get("_id", "unknown_id")
        
        # Send to CRAG worker
        sendMessage(
            conn=self.conn,
            messageId=chat_id,
            status="completed",
            destination=[f"CRAGWorker/generateAnswer/{chat_id}"],
            data={
                "prompt": prompt,
                "projectId": project_id
            }
        )
        
        response = create_success_response(
            "CRAG chat created successfully via GraphQL federation",
            {
                "chat_id": chat_id,
                "prompt": prompt,
                "projectId": project_id
            }
        )
        
        sendMessage(
            conn=self.conn,
            messageId=message.get("messageId"),
            status="completed",
            destination=["supervisor"],
            data=response.__dict__
        )

    async def mutation_create_chat_response(self, message: Dict[str, Any], param: str = None):
        """GraphQL mutation: createChatResponse (equivalent to POST /chat-response)"""
        data = message.get("data", {})
        project_id = data.get("projectId")
        response_text = data.get("response")
        
        # Create new chat history
        result = self.send_to_other_worker(
            destination=["DatabaseInteractionWorker/createNewHistory/"],
            data={
                "question": response_text,
                "projectId": project_id
            }
        )
        
        chat_id = result.get("result", [{}])[0].get("_id", "unknown_id")
        
        # Send to logical fallacy response worker
        sendMessage(
            conn=self.conn,
            messageId=chat_id,
            status="completed",
            destination=["LogicalFallacyResponseWorker/removeLFResponse/"],
            data={
                "response": response_text,
                "chat_id": chat_id
            }
        )
        
        response = create_success_response(
            "Chat response created successfully via GraphQL federation",
            {
                "chat_id": chat_id,
                "response": response_text,
                "projectId": project_id
            }
        )
        
        sendMessage(
            conn=self.conn,
            messageId=message.get("messageId"),
            status="completed",
            destination=["supervisor"],
            data=response.__dict__
        )

    def get_federation_schema(self) -> Dict[str, Any]:
        """Return the GraphQL federation schema for this subgraph"""
        return {
            "version": "2.0",
            "subgraph": "chatbot-worker-subgraph-2",
            "entities": self.federation_schema,
            "resolvers": list(self.resolvers.keys()),
            "port": self._port
        }


def main(conn: Connection, config: Dict[str, Any]):
    """Main entry point for the GraphQL federation worker"""
    worker = GraphQLFederationSubgraph2Worker()
    worker.run(conn, config.get("port", 5001))